'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var postcss = require('postcss');
var isValid = _interopDefault(require('is-valid-path'));
var path = require('path');
var fs = require('fs');
var crypto = require('crypto');
var mkdirp = require('mkdirp');
var chalk = _interopDefault(require('chalk'));

const extFilter = (exts, file) => {
    const ext = path.extname(file);
    return exts.some((value) => {
        return value === ext;
    });
};
const fileFilter = (files, file) => {
    const rootDir = process.cwd();
    const regs = files.map((value) => {
        const regStr = path.resolve(rootDir, value).replace(/\*\*/g, '.+?').replace(/\*/g, '[^\/]+?');
        return new RegExp(regStr);
    });
    return regs.some((value) => {
        return value.test(path.resolve(rootDir, file));
    });
};
const shouldHandle = (options) => {
    switch (true) {
        case options.include && !fileFilter(options.include, options.file):
            return false;
        case options.extensions && !extFilter(options.extensions, options.file):
            return false;
        case options.exclude && fileFilter(options.exclude, options.file):
            return false;
        default:
            return true;
    }
};

const rootDir = process.cwd();
const copyAsset = (file, dest, data, hash) => {
    let filename;
    if (hash) {
        const extname$$1 = path.extname(file);
        const fileHash = crypto.createHash('md5').update(data).digest('hex');
        filename = fileHash + extname$$1;
    }
    else {
        filename = path.basename(file);
    }
    if (!fs.existsSync(dest)) {
        mkdirp.sync(dest);
    }
    fs.writeFileSync(path.resolve(dest, filename), data);
    return filename;
};
const handleAsset = (options) => {
    const [file, cleanFile, search] = options.file.match(/(.+?)([\?\#].*)/) || ['', options.file, ''];
    const assetPath = path.resolve(path.dirname(options.importer), cleanFile);
    const data = fs.readFileSync(assetPath);
    switch (options.url) {
        case 'copy':
            const assetsPath = path.resolve(rootDir, options.assetsPath);
            const filename = copyAsset(assetPath, assetsPath, data, options.hash);
            if (options.publicPath) {
                return options.publicPath + filename;
            }
            else {
                return path.resolve('/', options.assetsPath, filename + search);
            }
        case 'inline':
            const type = path.extname(assetPath).replace('.', '');
            return `data:image/${type};base64,${data.toString('base64')}`;
        default:
            return options.file + search;
    }
};

const warn = (message) => {
    console.warn(chalk.bold.yellow(message));
};
const validateOptions = (options) => {
    if (!options) {
        return false;
    }
    if (options.url && options.url !== 'copy' && options.url !== 'inline') {
        warn(`(!) The url option must be one of "copy" or "inline".`);
    }
    if (options.url === 'copy' && !options.publicPath) {
        warn(`(!) Missing options "publicPath", publicPath should be specified in "copy" mode.`);
    }
    if (options && options.url === 'copy' && !options.assetsPath) {
        throw new Error(`Missing option "assetsPath".`);
    }
};

var index = postcss.plugin('postcss-file', (options) => {
    validateOptions(options);
    const opts = options && Object.prototype.isPrototypeOf(options) ? options : {
        url: 'inline'
    };
    return function (root) {
        root.walkDecls(/(background|src)/, function (decl) {
            if (decl.handled) {
                return;
            }
            decl.handled = true;
            if (!/url/.test(decl.value)) {
                return;
            }
            const urlReg = /url\((\"|\')?(.+?)(\1)\)/g;
            decl.value = decl.value.replace(urlReg, (match, $1 = '', $2, $3 = '') => {
                const file = $2;
                if (!isValid(file)) {
                    return `url(${$1 + $2 + $3})`;
                }
                const handleOptions = {
                    include: opts.include,
                    exclude: opts.exclude,
                    extensions: opts.extensions,
                    file
                };
                if (!shouldHandle(handleOptions)) {
                    return match;
                }
                const urlValue = handleAsset(Object.assign({}, opts, { importer: decl.source.input.file, file }));
                return `url(${$1 + urlValue + $3})`;
            });
        });
    };
});

module.exports = index;
